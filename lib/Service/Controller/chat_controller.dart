import 'package:flutter/material.dart';
import 'package:get_storage/get_storage.dart';
import 'package:gathering_app/Service/Api%20service/network_caller.dart';
import 'package:gathering_app/Service/urls.dart';

import 'package:gathering_app/Model/ChatModel.dart';

import 'package:gathering_app/Model/MessageModel.dart';
import 'package:gathering_app/Service/Controller/auth_controller.dart';
import 'package:gathering_app/Service/Controller/profile_page_controller.dart';
import 'package:gathering_app/Service/Socket/socket_service.dart';

class ChatController extends ChangeNotifier {
  bool _inProgress = false;
  String? _errorMessage;
  List<ChatModel> _chatList = [];
  int _unreadCount = 0;

  bool get inProgress => _inProgress;
  String? get errorMessage => _errorMessage;
  List<ChatModel> get chatList => _chatList;
  int get unreadCount => _unreadCount;

  final SocketService _socketService = SocketService();

  void initSocket(String chatId) {
    String? myId = AuthController().userId;
    if (myId == null || myId.isEmpty) {
      final cachedProfile = GetStorage().read<Map<String, dynamic>>('cached_user_profile');
      myId = cachedProfile?['id']?.toString() ?? cachedProfile?['_id']?.toString();
    }
    
    final token = AuthController().accessToken;
    debugPrint("üöÄ initSocket - chatId: $chatId, myId: $myId, hasToken: ${token != null}");

    if (token != null) {
      _socketService.connect(token);
      
      // Listen for messages: getMessage::chatId
      final eventName = "getMessage::$chatId";
      print("EventName: $eventName"); 
      debugPrint("üëÇ Listening for socket event: $eventName");
      
      _socketService.off(eventName); // Ensure no duplicate listeners
      _socketService.on(eventName, (data) {
        debugPrint("üì© Received socket message for $chatId: $data");
        if (data != null) {
          final newMessage = MessageModel.fromJson(data);
          
          // Avoid duplicates
          final exists = _messageList.any((m) => m.sId == newMessage.sId);
          if (!exists) {
            _messageList.insert(0, newMessage);
            notifyListeners();
          } else {
            debugPrint("‚è≠Ô∏è Message ${newMessage.sId} already exists, skipping insert.");
          }
        }
      });
    } else {
      debugPrint("‚ö†Ô∏è initSocket failed: Token is null");
    }
  }

  void disposeSocket(String chatId) {
    _socketService.off("getMessage::$chatId");
  }

  void initChatListSocket() {
    String? myId = AuthController().userId;
    if (myId == null || myId.isEmpty) {
      final cachedProfile = GetStorage().read<Map<String, dynamic>>('cached_user_profile');
      myId = cachedProfile?['id']?.toString() ?? cachedProfile?['_id']?.toString();
    }

    final token = AuthController().accessToken;
    debugPrint("üöÄ initChatListSocket - myId: $myId, hasToken: ${token != null}");

    if (myId != null && token != null) {
      _socketService.connect(token);
      
      final eventName = "updateChatList::$myId";
      debugPrint("üëÇ Listening for chat list socket event: $eventName");
      
      _socketService.off(eventName);
      _socketService.on(eventName, (data) {
        debugPrint("üì¨ Received chat list update socket event for $myId: $data");
        getChats(); // Simply refresh the chat list
      });
    } else {
      debugPrint("‚ö†Ô∏è initChatListSocket failed: myId ($myId) or token (${token != null}) is missing");
    }
  }

  void disposeChatListSocket() {
    final myId = AuthController().userId;
    if (myId != null) {
      _socketService.off("updateChatList::$myId");
    }
  }

  Future<String?> createChat(String otherUserId) async {
    // ... existing createChat implementation ...
    _inProgress = true;
    _errorMessage = null;
    notifyListeners();

    final response = await NetworkCaller.postRequest(
      url: Urls.chatUrl(otherUserId),
      body: {}, 
    );

    _inProgress = false;

    if (response.isSuccess && response.body != null) {
      final data = response.body!['data'];
      if (data != null && data['_id'] != null) {
        notifyListeners();
        return data['_id'];
      }
    } else {
      _errorMessage = response.errorMessage;
    }
    
    notifyListeners();
    return null;
  }

Future<void> getChats() async {
  _inProgress = true;
  notifyListeners();
  
  final response = await NetworkCaller.getRequest(url: Urls.getAllChatsUrl);
  
  _inProgress = false;

  if (response.isSuccess) {
    debugPrint("‚úÖ getChats Response Body: ${response.body}");
    
    // The data structure is: {"data": {"chats": [...]}}
    final dynamic dataField = response.body?['data'];
    
    List? rawList;
    if (dataField != null && dataField is Map) {
      debugPrint("üîç dataField keys: ${dataField.keys.toList()}");
      // Check for "chats" array inside the data object
      rawList = dataField['chats'] as List?;
      
      // Try multiple possible keys for unread count in both dataField and response.body
      final dynamic uc = dataField['unreadCount'] ?? 
                         dataField['totalUnreadCount'] ?? 
                         dataField['unread_count'] ??
                         response.body?['unreadCount'] ??
                         response.body?['totalUnreadCount'];
      
      _unreadCount = int.tryParse(uc?.toString() ?? '0') ?? 0;
      
      debugPrint("üîç Found chats array: ${rawList?.length ?? 0} items, unreadCount from API: $_unreadCount (from $uc)");

      // Fallback: If API says 0, but we have lists, calculate manually just in case
      if (_unreadCount == 0 && rawList != null && rawList.isNotEmpty) {
        int manualCount = 0;
        for (var chat in rawList) {
          if (chat is Map && chat['lastMessage'] != null && chat['lastMessage']['seen'] == false) {
            manualCount++;
          }
        }
        if (manualCount > 0) {
          _unreadCount = manualCount;
          debugPrint("üí° Manual unreadCount calculation: $_unreadCount");
        }
      }
    }
    
    if (rawList != null && rawList.isNotEmpty) {
      final authId = AuthController().userId;
      String? currentUserId = authId;
      if (currentUserId == null || currentUserId.isEmpty) {
        final cachedProfile = GetStorage().read<Map<String, dynamic>>('cached_user_profile');
        currentUserId = cachedProfile?['id']?.toString() ?? cachedProfile?['_id']?.toString();
      }

      debugPrint("üîç getChats - MyID: $currentUserId");

      _chatList = rawList.map<ChatModel>((chatData) {
        final participants = chatData['participants'] as List?;
        Map<String, dynamic>? otherUserMap;
        String? otherUserId;
        String? otherUserName;
        
        if (participants != null && participants.isNotEmpty) {
          // Find the other user (not current user)
          for (var p in participants) {
            if (p is Map<String, dynamic>) {
              String? pId = (p['_id'] ?? p['id'])?.toString();
              if (pId != null && currentUserId != null && pId != currentUserId) {
                otherUserMap = p;
                otherUserId = pId;
                otherUserName = p['name']?.toString();
                break;
              }
            }
          }
          //close this model
          if (otherUserId == null && participants.isNotEmpty) {
            final first = participants.first;
            if (first is Map<String, dynamic>) {
              otherUserMap = first;
              otherUserId = (first['_id'] ?? first['id'])?.toString();
              otherUserName = first['name']?.toString();
            }
          }
        }

        // Get last message text and seen status
        String? lastMessageText;
        bool lastMessageSeen = true;
        final lastMessage = chatData['lastMessage'];
        if (lastMessage != null && lastMessage is Map) {
          lastMessageText = lastMessage['text']?.toString() ?? 'Sent a message';
          lastMessageSeen = lastMessage['seen'] == true;
        } else {
          lastMessageText = 'No messages yet';
        }

        // Robust profile image parsing
        String? finalImageIcon;
        String? rawImageIcon = otherUserMap?['profile']?.toString() ??
                          otherUserMap?['profileImage']?.toString() ?? 
                          otherUserMap?['image']?.toString() ?? 
                          otherUserMap?['avatar']?.toString();
        
        if (rawImageIcon != null && rawImageIcon.isNotEmpty) {
          if (rawImageIcon.startsWith('http')) {
            finalImageIcon = rawImageIcon;
          } else {
            finalImageIcon = "${Urls.baseUrl}${rawImageIcon.startsWith('/') ? '' : '/'}$rawImageIcon";
          }
        }

        return ChatModel(
          id: chatData['_id']?.toString(),
          otherUserId: otherUserId,
          name: otherUserName ?? 'Unknown User',
          imageIcon: finalImageIcon,
          currentMessage: lastMessageText,
          time: chatData['updatedAt']?.toString() ?? '',
          status: 'offline', 
          isGroup: false,
          isSeen: lastMessageSeen,
        );
      }).toList();
      
      debugPrint("‚úÖ Parsed ${_chatList.length} chats");
    } else {
      debugPrint("‚ö†Ô∏è No chats found or empty list");
      _chatList = [];
    }
  } else {
    _errorMessage = response.errorMessage;
    debugPrint("‚ùå Error getting chats: $_errorMessage");
  }
  
  notifyListeners();
}

void markChatAsSeenLocally(String chatId) {
  final index = _chatList.indexWhere((chat) => chat.id == chatId);
  if (index != -1 && _chatList[index].isSeen == false) {
    _chatList[index].isSeen = true;
    if (_unreadCount > 0) _unreadCount--;
    notifyListeners();
    debugPrint("‚úÖ Chat $chatId marked as seen locally, new unreadCount: $_unreadCount");
  }
}

  List<MessageModel> _messageList = [];
  List<MessageModel> get messageList => _messageList;

  Future<void> getMessages(String chatId) async {
    _inProgress = true;
    notifyListeners();
    
    final response = await NetworkCaller.getRequest(url: Urls.getMessage(chatId));
    
    _inProgress = false;

    if (response.isSuccess) {
      final dynamic dataField = response.body?['data'];
      List? rawList;
      if (dataField is List) {
        rawList = dataField;
      } else if (dataField is Map && dataField['data'] is List) {
        rawList = dataField['data'];
      }
      
      if (rawList != null) {
        final messages = rawList.map((e) => MessageModel.fromJson(e)).toList();
        // Sort: Newest First (Descending) because we use reverse: true in UI
        messages.sort((a, b) {
           DateTime dateA = DateTime.tryParse(a.createdAt ?? '') ?? DateTime(1970);
           DateTime dateB = DateTime.tryParse(b.createdAt ?? '') ?? DateTime(1970);
           return dateB.compareTo(dateA);
        });
        _messageList = messages;
      }
    } else {
      _errorMessage = response.errorMessage;
    }
    notifyListeners();
  }

  Future<bool> sendMessage(String chatId, String? text, {String? imagePath}) async {
    _inProgress = true; 
    notifyListeners();

    NetworkResponse response;

    if (imagePath != null) {
      // Send image and text via multipart request
      response = await NetworkCaller.multipartRequest(
        url: Urls.sendMessage,
        method: 'POST',
        fileKey: 'image',
        filePath: imagePath,
        fields: {
          "chatId": chatId,
          if (text != null && text.isNotEmpty) "text": text,
        },
      );
    } else {
      // Send text only via standard post request
      response = await NetworkCaller.postRequest(
        url: Urls.sendMessage,
        body: {
          "chatId": chatId,
          if (text != null && text.isNotEmpty) "text": text,
        },
      );
    }

    _inProgress = false;

    if (response.isSuccess) {
      await getMessages(chatId);
      return true;
    } else {
      _errorMessage = response.errorMessage;
      notifyListeners();
      return false;
    }
  }
}
